git branch xxx ： 创建分支（指针）xxx，指向当前最新的commit点
git log --oneline --decorate  ：  查看所有分支（指针）指向的commit点

HEAD分支（指针）：指向当前分支（指针）的commit点，即当前分支（指针）的  “别名” ！

使用git checkout进行分支切换时，会发生两件事：1.把HEAD分支（指针）指向当前分支（指针）；
                                           2.把当前工作目录切换到相应分支（指针）所代表的快照内容；
                                           (这很重要，每次checkout都会导致当前工作目录发生变化)
                                           
git checkout -b xxx ： 创建分支（指针）xxx，同时切换到xxx上去
  （以上等同于：git branch xxx ； git checkout xxx）
  
 ——————
git checkout -b <branch>  <remote>/<branch>  ： 创建branch，切换到branch上，同时让branch跟踪<remote>的<branch>分支
git checkout --track <remote>/<branch>       ： 设置当前分支跟踪remote的branch分支
 ——————

git merge yyy ： 把当前分支合并 “到”  yyy分支上，加入当前分支是xxx，那么就相当于给xxx赋值为yyy，xxx=yyy
            注：分支的合并，必须建立在commit的可访问前提下。不应当出现分支合并后，无法访问之前可访问的commit

git branch -d xxx ： 删除xxx分支（指针）

git branch --no-merged ： 罗列针对当前分支而言，所有还未合入的分支
git branch --merged    ： 罗列针对当前分支而言，已经合入了的分支

尝试删除一个尚未被merge到其他分支的分支时，会报警，因为当前分支没被merge到别的分支，所以他的一些信息可能会丢失。如果确实想删除
则用git branch -D xxx


远程引用是对远程仓库的引用（指针），包括分支和标签等。

查看所有远程引用：git ls-remote 
查看所有远程引用的详细信息：git remote show （remote name）

远程跟踪分支：
远程跟踪分支是远程分支状态的引用，无法像移动本地分支一样来移动这些远程跟踪分支，虽然这些分支也存在与本地
远程跟踪分支的移动，是由网络通讯时触发的（远程操作）
远程跟踪分支长这样：remote/branch   远程引用名/本地分支名

clone命令
git clone git@url
执行上述命令时，本地创建一个别名，用来指代url，同时创建一个名为origin/master的远程跟踪分支，最后在本地创建一个和远程分支一模一样的
master分支
      注：可使用 git clone git@url -o remote_name ，来把url重命名为remote_name，而不是原始的origin，这样的远程跟踪分支也会
         跟着变名字
      注：因为远程跟踪分支我们本地是操纵不了的，所以没必要知道他在哪，以及怎么用
      

注意：   clone命令无法指定clone哪一个分支，只会一次性把所有分支都clone下来，这才是一个完整的工程
         这也很好理解，因为分支是指针，数据是快照，这些东西是一个整体，互相配合才能还原出工作目录，因此不可分割开来

罗列所有分支（本地 & 远程）：git branch -a
git fetch origin ， 这个命令查找origin属于是哪个remote的别名，然后从其中抓取本地没有的数据，并且更新本地数据库，然后！然后！移动
远程跟踪分支到新的，更新后的位置


git push （remote name） （branch）   :   推送本地分支到远端，因为有远程跟踪分支的存在，所以只需要指明remote name即可，不需要指明
                                          远程服务器的哪个分支
    注：上面命令是简化的，完整的是   git push （remote name）  （branch）：（remote branch）
    
    
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

git fetch ： 从跟踪的远程分支上拿commit
git merge ： 合并分支，把指针移动到指定的commit上；如果需要，还会创建新的commit来兼容前面的多个分支
git pull  ： 从跟踪的远程分支上拿commit，并且合并到远程分支的当前commit点
git remote -va ： 查看所有branch（本地&远程仓库），其中会包含本地 & 远程分支的当前指向的commit点（也就是HEAD指向哪）

####创建、更改本地分支与远程分支的对应关系
git checkout -b <branch>  <remote>/<branch>  ： 创建branch，切换到branch上，同时让branch跟踪<remote>的<branch>分支
git checkout --track <remote>/<branch>       ： 同上
git branch --set-upstream-to <remote>/<branch>  ： 指定本地当前branch，跟踪remote的branch

#####查看本地分支与远程分支的对应关系
git remote show <remote>      ： 查看指定remote的所有分支情况（其中包括本地分支与远程分支的对应关系）
git branch -vv      ： 查看本地分支对应远程分支的情况（涵盖上一条命令的部分功能）


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
删除远程分支  
git push <remote> --delete <branch>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
整合分支的两种方法：合并(merge)和变基(rebase)

merge：对比分支之间的不同，生成一个能够涵盖这些分支变动的新commit（旧commit不变，产生新commit）
rebase：首先向前搜索，找到多个分支之间最近一次的公共父commit，然后重新对比修正多个分支，使这些分支随后的commit能够在一条线上，不产生
        新commit，只修改当前commit（旧commit改变，不产生新commit）

变基 vs. 合并
至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。
有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用_谎言_掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。
另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。
现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。
总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。


                                           
